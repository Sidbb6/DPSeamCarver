/**
 * CS 311 Programming Assignment #2 - Java Edition
 * UMass Amherst 2022 Fall
 * Instructor: Professor Ramesh Sitaraman
 * 
 * Instructions: Complete the sections marked with # TODO
 */

package PA2;

import java.util.ArrayList;
import java.util.Random;

import java.awt.image.*;
import java.awt.Color;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;

import java.nio.file.*;

import javax.imageio.ImageIO;


public class SeamCarver {
	public SeamCarver() {
	}

	public static double[][] computeEnergy(ArrayList<ArrayList<ArrayList<Integer>>> image){
		/**
		 * Compute the energy of a given pixel on the image.
		 * 
		 * The energy of a pixel in an RGB-channel image is defined as:
		 * 	1000, if the pixel is on the edge
		 * 	sum([
		 * 		delta_xr ^ 2,
		 * 		delta_xg ^ 2,
		 * 		delta_xb ^ 2,
		 * 		delta_yr ^ 2,
		 * 		delta_yg ^ 2,
		 * 		delta_yb ^ 2,
		 * 	]) ^ (1 / 2), otherwise
		 * 
		 * Notation: delta_xr indicates the difference in the R channel between
		 * adjacent pixels in the x (width) direction.
		 * 
		 * This is a specific example for an RGB-channel image. Your code
		 * should work with a 2D image with arbitrary number of channels.
		 * 
		 * Input:
		 * 	image: int type nested ArrayList of the shape:
		 * 		(image height, image width, number of color channels)
		 * 
		 * Return:
		 * 	energy: array of energies of the shape:
		 * 		(image_height, image_width)
		 * 
		 */

		// --------------------- TODO -------------------------------
		// Begin your work here
		// Image height, width, and number of colors
		int imgH = image.size();
		int imgW = image.get(0).size();
		int numColors = image.get(0).get(0).size();

		double[][] energy = new double[imgH][imgW];
		for (int r = 0; r < imgH; r++) {
			for (int c = 0; c < imgW; c++) {
				// Assigns border of the image to 1000 energy
				if (r == 0 || c == 0 || r == imgH-1 || c == imgW-1) 
					energy[r][c] = 1000;
				else {
					// Calculates energy gradient for any range of color channels
					double delta_x = 0;
					for (int i = 0; i < numColors; i++) 
						delta_x += Math.pow((image.get(r).get(c+1).get(i) - image.get(r).get(c-1).get(i)), 2);	

					double delta_y = 0;
					for (int i = 0; i < numColors; i++) 
						delta_y += Math.pow((image.get(r+1).get(c).get(i) - image.get(r-1).get(c).get(i)), 2);	

					energy[r][c] = Math.sqrt(delta_x + delta_y);
				}
			}
		}			
		
		return energy;
		// --------------------- END TODO ---------------------------
	}

	public static int[] findVerticalSeam(ArrayList<ArrayList<ArrayList<Integer>>> image){
		/**
		 * Find the vertical "seam" with the least cumulative energy and return
		 * a list/array of the horizontal indices of the seam
		 * 
		 * Input:
		 * 	image: int type nested ArrayList of the shape:
		 * 		(image height, image width, number of color channels)
		 * 
		 * Return:
		 * 	An (image height, ) sized array of integers ranging between
		 * 	[0, image width - 1], representing the ordered horizontal indices of the seam
		 */

		int x, y;
		int imageHeight = image.size();
		int imageWidth = image.get(0).size();
		int channelDepth = image.get(0).get(0).size();
		double[][] energy = computeEnergy(image);

		// Add a small random noise to the energy, which is generated by an image
		// assumed to contain integer values between [0, 255] (thus may contain many
		// duplicate values), to avoid variations between implementations yielding
		// different results.
		double noise;
		int imageSize = imageHeight * imageWidth * channelDepth;
		double normalizationFactor = 1000 * Math.pow(imageSize, 0.5);
		Random rnd = new Random(0);

		for (y = 0; y < imageHeight; y++){
			for (x = 0; x < imageWidth; x++){
				noise = rnd.nextGaussian() / normalizationFactor;
				energy[y][x] += noise;
			}
		}

		return findVerticalSeam(energy);
	}
	
	public static int[] findVerticalSeam(double[][] energy) {
		/**
		 * Find the vertical "seam" with the least cumulative energy and return
		 * a list/array of the horizontal indices of the seam
		 * 
		 * Input:
		 * 	energy: double type 2D array of shape:
		 * 		(image height, image width)
		 * 
		 * Return:
		 * 	An (image height, ) sized array of integers ranging between
		 *  [0, image width - 1], representing the ordered horizontal indices of the seam
		 */
		
		int imageHeight = energy.length;
		int imageWidth = energy[0].length;

		// --------------------- TODO -------------------------------

		/*
		 * Adapt an O(n^2) path-finding algorithm to find the seam with the
		 * least cumulative energy.
		 *
		 * The vertical seam of least cumulative energy is defined as:
		 *     A (image height, ) sized array of indices in the range
		 *     [0, image width - 1], such that each pair of consecutive indices
		 *     differ by no more than 1, and such that the sum of the energy on
		 *     these pixels is the smallest that can be constructed from such a path
		 *
		 * This, when visualized on an image, would translate to a squiggly line
		 * down an image. Deleting these pixels would yield 2 pieces of image
		 * that, when pieced together, would result in an image exactly 1 pixel
		 * narrower than the original
		 *
		 * Nota bene: You shouldn't need to ever use the variable "image"!
		 * Everything you need is already computed in the variable "energy".
		 */

		// Begin your work here
		// DP solution building a table of the sum of energies 
		double[][] sumETble = new double[imageHeight][imageWidth];

		// Fill first row 
		for (int c = 0; c < imageWidth; c++) 
			sumETble[0][c] = energy[0][c];

		// Fill rest of table 
		for (int r = 1; r < imageHeight; r++) {
			for (int c = 0; c < imageWidth; c++) {	
				// Checks energy up (directly above)
				double min = sumETble[r-1][c];
				// Checks energy up and left
				if (c > 0)
				min = Math.min(min, sumETble[r-1][c-1]);
				// Checks energy up and right
				if (c < imageWidth-1)
					min = Math.min(min, sumETble[r-1][c+1]);
				// Stores sum of min energy
				sumETble[r][c] = min + energy[r][c];
			}
		}

		// Stores horizontal indices of the vertical seam
		int[] seam = new int[imageHeight];
		// Min energy of the last row of sums
		seam[imageHeight-1] = indexOfMin(sumETble[imageHeight-1], 0, imageWidth-1);
		for (int r = imageHeight - 2; r >= 0; r--) {
			// Using the last column to determine next column
			int c = seam[r+1];
			seam[r] = indexOfMin(sumETble[r], Math.max(0, c-1), Math.min(c+1, imageWidth-1));
		}

		return seam;
	}

	// Finds the index of the minimum element in an array between two bounds
	private static int indexOfMin(double[] arr, int startIn, int endIn) {
		int minIn = startIn;
		for (int i = startIn; i <= endIn; i++) {
			if (arr[i] < arr[minIn]) 
				minIn = i;
		}
		return minIn;
	}
	// --------------------- END TODO ---------------------------

	// sequence of indices for horizontal seam
	public static int[] findHorizontalSeam(ArrayList<ArrayList<ArrayList<Integer>>> image){
		/**
		 * Find the horizontal "seam" with the least cumulative energy and return
		 * a list/array of the vertical indices of the seam
		 * 
		 * Input:
		 * 	image: int type nested ArrayList of the shape:
		 * 		(image height, image width, number of color channels)
		 * 
		 * Return:
		 * 	An (image width, ) sized array of integers ranging between
		 * 	[0, image height - 1], representing the ordered vertical indices of the seam
		 */

		// this is equivalent to finding the vertical seam on the transposed image
		// so we don't need to repeat ourselves
		ArrayList<ArrayList<ArrayList<Integer>>> transposedImage = transposeImage(image);
		
		return findVerticalSeam(transposedImage);
	}
	
	public static ArrayList<ArrayList<ArrayList<Integer>>> transposeImage(ArrayList<ArrayList<ArrayList<Integer>>> image){
		/**
		 * Oh Lord please forgive me for what I'm about to do
		 * 
		 * This function creates a copy of the transposed image.
		 * FIXME: find a way to eliminate this entire copy operation.
		 */
		int x, y, z;
		int imageHeight = image.size();
		int imageWidth = image.get(0).size();
		int channelDepth = image.get(0).get(0).size();
		ArrayList<ArrayList<ArrayList<Integer>>> transposedImage = new ArrayList<ArrayList<ArrayList<Integer>>>();

		for (x = 0; x < imageWidth; x++){
			transposedImage.add(new ArrayList<ArrayList<Integer>>());
			for (y = 0; y < imageHeight; y++){
				transposedImage.get(x).add(new ArrayList<Integer>());
				for (z = 0; z < channelDepth; z++){
					transposedImage.get(x).get(y).add(image.get(y).get(x).get(z));
				}
			}
		}
		
		return transposedImage;
	}
	
	public static void writeSeamsToFile(String path, int[][] seams) throws IOException{
		/**
		 * Oh Lord please forgive me for what I am about to do.
		 * 
		 * This function writes a 2D int array into comma separated, newline delimited values in a plain text file.
		 * FIXME: Use a more compact format than a plain text file
		 * FIXME: Perhaps... actually do the visualization in Java instead of outsourcing to Python?
		 * 
		 * GUH!
		 */

		int i, j;
		String outString = "";
		Path outPath = Paths.get(path);
		
		// delete previous output file
		Files.deleteIfExists(outPath);
		BufferedWriter writer = Files.newBufferedWriter(outPath);
		
		for (i = 0; i < seams.length; i++) {
			outString = "";
			for (j = 0; j < seams[i].length; j++) {
				outString += Integer.toString(seams[i][j]) + ',';
			}
			// replace final comma with newline
			outString = outString.substring(0, outString.length() - 1) + '\n';
			writer.append(outString);
		}
		writer.close();
	}
	
	public static void writeEnergyToFile(String path, double[][] energy) throws IOException{
		/**
		 * Oh Lord please forgive me for what I am about to do.
		 * 
		 * This function writes a 2D double array into comma separated, newline delimited values in a plain text file.
		 * FIXME: Use a more compact format than a plain text file
		 * FIXME: Perhaps... actually do the visualization in Java instead of outsourcing to Python?
		 * 
		 * GUH!
		 */
		
		int x, y;
		String outString;
		Path outPath = Paths.get(path);
		
		// delete previous output file
		Files.deleteIfExists(outPath);
		BufferedWriter writer = Files.newBufferedWriter(outPath);
		
		for (y = 0; y < energy.length; y++) {
			outString = "";
			for (x = 0; x < energy[y].length; x++) {
				outString += Double.toString(energy[y][x]) + ',';
			}
			// replace final comma with newline
			outString = outString.substring(0, outString.length() - 1) + '\n';
			writer.append(outString);
		}
		writer.close();
	}

	public static void main(String[] args) throws IOException{
		/**
		 * Generates output files to be rendered by the provided Python script for visualization
		 * Tried to do this in Java but chickened out after reading an example for generating GIF files
		 * 
		 * Sorry guys :( You would have to install python3 and the libraries numpy and pillow
		 */


		// --------------------- TODO -------------------------------

		// After you finished implementing the two functions, return here and change
		// "sample_image.png" to "InputImage.png" to generate your image
		// for part 3, the written section
		// You would also need to change the corresponding filename in your
		// visualization script.

		String sampleImagePath = "sample_image.png";

		// --------------------- END TODO ---------------------------
		
		int i, j;
		int x, y, RGBVal;
		int[] seam;
		int[][] seams;
		double [][] energy;
		Color color;
		
	    // -------------------- reading file -------------------------

		BufferedImage sampleImage = ImageIO.read(new File(sampleImagePath));
		int originalHeight = sampleImage.getHeight();
		int originalWidth = sampleImage.getWidth();
		ArrayList<ArrayList<ArrayList<Integer>>> image = new ArrayList<ArrayList<ArrayList<Integer>>>();

		for (y = 0; y < sampleImage.getHeight(); y++) {
			image.add(new ArrayList<ArrayList<Integer>>());
			for (x = 0; x < sampleImage.getWidth(); x++) {
				image.get(y).add(new ArrayList<Integer>());
				RGBVal = sampleImage.getRGB(x, y);
				color = new Color(RGBVal);
				image.get(y).get(x).add(color.getRed());
				image.get(y).get(x).add(color.getGreen());
				image.get(y).get(x).add(color.getBlue());
			}
		}

	    // -------------------- energy -------------------------------
		
		energy = computeEnergy(image);

		writeEnergyToFile("energy.out", energy);
		
		// -------------------- vertical carving ---------------------
		
		int numCarves = Math.min(originalWidth, 200);
		seams = new int [numCarves][originalHeight];
		
		for (i = 0; i < numCarves; i++) {
			seam = findVerticalSeam(image);
			// store the computed seam
			for (j = 0; j < originalHeight; j++) {
				seams[i][j] = seam[j];
			}
			// remove the seam
			for (j = 0; j < originalHeight; j++) {
				image.get(j).remove(seam[j]);
			}
		}
		
		writeSeamsToFile("verticalSeams.out", seams);
		
		// -------------------- horizontal carving -------------------
		
		// Oh Lord please forgive me for what I'm about to do
		image = new ArrayList<ArrayList<ArrayList<Integer>>>();

		for (y = 0; y < sampleImage.getHeight(); y++) {
			image.add(new ArrayList<ArrayList<Integer>>());
			for (x = 0; x < sampleImage.getWidth(); x++) {
				image.get(y).add(new ArrayList<Integer>());
				RGBVal = sampleImage.getRGB(x, y);
				color = new Color(RGBVal);
				image.get(y).get(x).add(color.getRed());
				image.get(y).get(x).add(color.getGreen());
				image.get(y).get(x).add(color.getBlue());
			}
		}
		
		ArrayList<ArrayList<ArrayList<Integer>>> transposedImage = transposeImage(image);
		int transposedHeight = sampleImage.getWidth();
		int transposedWidth = sampleImage.getHeight();
		
		numCarves = Math.min(transposedWidth, 200);
		seams = new int [numCarves][transposedHeight];
		
		for (i = 0; i < numCarves; i++) {
			seam = findVerticalSeam(transposedImage);
			// store the computed seam
			for (j = 0; j < transposedHeight; j++) {
				seams[i][j] = seam[j];
			}
			// remove the seam
			for (j = 0; j < transposedHeight; j++) {
				transposedImage.get(j).remove(seam[j]);
			}
		}
		
		writeSeamsToFile("horizontalSeams.out", seams);
	}
}